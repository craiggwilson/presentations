<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Schema Design By Example</title>

		<meta name="description" content="Schema Design by Example">
		<meta name="author" content="10gen">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/main.css">
		<link rel="stylesheet" href="css/theme/mongodb.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script>
			// If the query includes 'print-pdf' we'll use the PDF print sheet
			var print = ( window.location.search.match( /print-pdf/gi ) ? true: false );
			document.write( '<link rel="stylesheet" href="css/print/' + ( print ? 'pdf': 'paper' ) + '.css" type="text/css" media="print">' );
			if (print) { document.querySelector( 'html' ).classList.add('print');}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Used to fade in a background when a specific slide state is reached -->
			<div class="state-background"></div>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-state="title-slide">
					<h1 class="logo">MongoDB</h1>
					<h2>Schema Design By Example</h2>

					Craig Wilson - <craig.wilson@10gen.com>

					twitter: <a href="http://twitter.com/craiggwilson">@craiggwilson</a>
				</section>

				<section>
					<h1>Today's Talk</h1>

					<ul>
						<li>Why is schema design important?</li>
						<li>Questions to ask yourself when designing a schema.</li>
						<li>What schema elements are available for you to design around?</li>
						<li>Examples.</li>
					</ul>
				</section>

				<section>
					<h1>Why is schema design important?</h1>
					
					<ul>
						<li class="fragment">mongoDB gives you a lot of flexibility and power over the data you are representing.</li>
						<li class="fragment">The way you model your data should be a function of how your application uses it.</li>
						<li class="fragment">Your data may grow and its priorities may change over time. Your schema can help you anticipate this.</li>

					</ul>
					
				</section>

				<section>
					<h1>Questions to Ask Yourself</h1>

					<ul>
						<li class="fragment">What are the usage patterns of your data? Will your application be read or write intensive?</li>
						<li class="fragment">
							How do you anticipate your documents changing over time?
							<ul>
								<li>Will they grow or shrink?</li>
								<li>Will they get normalized or denormalized</li>
							</ul>
						<li class="fragment">Are there some immutable fields that you can leverage?</li>
						<li class="fragment">Do you anticipate needing to shard your data?</li>
					</ul>
				</section>

				<section>
					<h1>Available Schema Elements</h1>

					<ul> 
						<li class="fragment">
							Primitive Types
							<ul>
								<li>Double</li>
								<li>UTF-8 String</li>
								<li>
									Binary
									<ul>
										<li>Raw</li>
										<li>Guid
										<li>MD5</li>
									</ul>
								</li>
								<li>ObjectId</li>
								<li>Boolean</li>
								<li>UTC DateTime</li>
								<li>Null</li>
								<li>Regular Expression</li>
								<li>32-bit Integer</li>
								<li>Timestamp</li>
								<li>64-bit Integer</li>
							</ul>
						</li>
						<li class="fragment">
							Rich Types
							<ul>
								<li>Documents</li>
								<li>Arrays</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<section>
						<h1>Example: Library Application</h1>

						<p>An application for saving a collection of books.<p>
					</section>
					<section>
						<img src="img/books_index.png" style="max-height:150%;"/>
					</section>
					<section>
						<img src="img/authors_index.png" style="max-height:150%;"/>
					</section>
				</section>

				<section class="center-image">
					<section>
						<h1>Schema - Book</h1>
						<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  "title": string,
  "author": int,
  "isbn": string,
  "slug": string,
  "publisher": {
    "name": string,
    "date": timestamp,
    "city": string
  },
  "available": boolean,
  "pages": int,
  "summary": string,
  "subjects": [string, string]
  "notes": [{
  	"user": int,
  	"note": string
  }],
  "language": string
}
						</code></pre>
					</section>
					<section>
						<h1>Schema - Author</h1>
						<pre><code class="language-javascript small-size">
author = {
  "_id": int,
  "first_name": string,
  "last_name": string
}
						</code></pre>
					</section>
					<section>
						<h1>Schema - User</h1>
						<pre><code class="language-javascript small-size">
user = {
  "_id": int,
  "username": string,
  "password": string
}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Query Samples</h1>

						<pre><code class="language-javascript small-size">
> db.authors.findOne()
{
  _id: 1,
  first_name: "F. Scott",
  last_name: "Fitgerald"
}

> db.users.findOne()
{
  _id: 1,
  username: "craig.wilson@10gen.com",
  password: "slsjfk4odk84k209dlkdj90009283d"
}
						</code></pre>
					</section>
					<section>
						<pre><code class="language-javascript small-size">
> db.books.findOne()
{
  _id: 1,
  title: "The Great Gatsby",
  slug: "9781857150193-the-great-gatsby",
  author: 1,
  available: true,
  isbn: "9781857150193",
  pages: 176,
  publisher: {
    publisher_name: "Everyman’s Library",
    date: ISODate("1991-09-19T00:00:00Z"),
    publisher_city: "London"
  },
  summary: "Set in the post-Great War...",
  subjects: ["Love stories", "1920s", "Jazz Age"],
  notes: [ 
    { user: 1, note: "One of the best..."},
    { user: 2, note: "It’s hard to..."}
  ],
  language: "English"
}
						</code></pre>
					</section>
				</section>
				
				
				<section>
					<h1>What should we keep in mind as we design this schema?</h1>
				</section>
				
				
				<section>
					<section>
						<h1>Applied Principles and Patterns</h1>
						<div class="fragment">
							<h3>Principle: Schema-less does NOT mean No-Schema</h3>
							<ul>
								<li class="fragment">
									Schema is defined and expectations are set at the application level.
									<pre><code class="language-javascript small-size">
user = {
  "_id": int,
  "username": string,
  "password": string
}
									</code></pre>
								</li>
								<li class="fragment">
									Design should take advantage of flexibility, only when appropriate.
									<pre><code class="language-javascript small-size">
db.everything.find()
{
  _id: 893,
  first_name: "Jim",
  last_name: "McJim"	
}
{
  _id: "'66 mustang",
  make: "Ford",
  model: "Mustang",
  year: "1966"
}								</code></pre>
								</li>
							</ul>
						</div>
					</section>
					<section>
						<h3>Principle: Use Rich Documents</h3>
						<ul>
							<li class="fragment">
								Pattern: Embedded Documents
								<pre><code class="language-javascript small-size">
book.publisher: 
{
  publisher_name: "Everyman’s Library",
  date: ISODate("1991-09-19T00:00:00Z"),
  city: "London",
},
								</code></pre>
							</li>
							
<aside class="notes">
In general, use embedded documents when possible.
Usually one embeds documents that seldom change and data that's not interesting enough to warrant a document of its own. 
</aside> 
			
							<li class="fragment">
								Pattern: Embedded Arrays
								<pre><code class="language-javascript small-size">
book.subjects: ["Love stories", "1920s", "Jazz Age"],
								</code></pre>
							</li>
							
<aside class="notes">
Multi-key indexes - will index each element of the array.
Query: db.books.find( { subject: { $all: [ 'Love stories', 'Jazz Age' ] } } )
$addToSet and $pull to add and remove keys 
Whether to embed positionally using an array or embedded doc is a matter of taste and depends on whether you want to use a multi-key index.
</aside>

							<li class="fragment">
								Pattern: Embedded Arrays of Documents
								<pre><code class="language-javascript small-size">
book.notes: [
  { user: 1, note: "One of the best..."},
  { user: 2, note: "It’s hard to..."}
],
								</code></pre>
							</li>
							
<aside class="notes">
You can even index on keys inside embedded documents. 
</aside>
						</ul>
					</section>
					</section>
				<section>
					<section>
						<h1>Application Queries</h1>
						<h3>Query for all the books by a specific author</h3>
						<pre><code class="language-javascript small-size">
> author = db.authors.findOne({first_name: "F. Scott", last_name: "Fitzgerald"});

> db.books.find({author: author._id})
{
  ...	
}
{
  ...
}
						</code></pre>	
					</section>
					
					<section>
						<h3>Query for books by title</h3>
						<pre><code class="language-javascript small-size">
> db.books.find({title: "The Great Gatsby"})
{
  ...	
}
						</code></pre>
					</section>
					<section>
						<h3>Query for books in which I have made notes</h3>
						<pre><code class="language-javascript small-size">
> db.books.find({notes.user: 1})
{
  ...	
}
{
  ...
}
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Schema Evolution for read-heavy use #1</h1>
						<h3>Query for books by an author's first name</h3>
						<pre><code class="language-javascript small-size">
> authors = db.authors.find( { first_name: /^f.*/i }, {_id: 1})

> authorIds = authors.map(function(x) { return x._id; })

> db.books.find({author: { $in: authorIds } })
{
  ...	
}
{
  ...
}
						</code></pre>
					</section>
					<section>
						<h3>Principle: Documents Should Reflect Query Patterns</h3>
						<ul>
							<li class="fragment">
								Pattern: Partially Embedded Documents
								<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  "title": string,
  "author": {
    "author": int,
    "name": string
  },
  ...
}
								</code></pre>
							</li>
						<li class="fragment">
							Query for books by an author's first name using an embedded document with cached name.
							<pre><code class="language-javascript small-size">
> db.books.find({author.name: /^f.*/i })
{
  ...	
}
{
  ...
}
							</code></pre>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h1>Schema Evolution for read-heavy use #2</h1>
						<h3>Query for a book's notes</h3>
						<pre><code class="language-javascript small-size">
> db.books.find({title: "The Great Gatsby"}, {_notes: 1})
{
  _id: 1,
  notes: [
    { user: 1, note: "One of the best..."},
    { user: 2, note: "It’s hard to..."}
  ]
}
						</code></pre>
					</section>
					<section>
						<h3>Principle: Take Advantage of Immutable Data</h3>
						<ul>
							<li class="fragment">
								Username is the natural key and is immutable
								<pre><code class="language-javascript small-size">
user = {
  "_id": string,
  "password": string
}

book = {
  // ...
  "notes": [{
    "user": string,
    "note": string
  }],
  // ...
}
								</code></pre>
							</li>
							<li class="fragment">
								Query for a book's notes
								<pre><code class="language-javascript small-size">
> db.books.find({title: "The Great Gatsby"}, {_notes: 1})
{
  _id: 1,
  notes: [
    { user: "craig.wilson@10gen.com", note: "One of the best..."},
    { user: "jmcjack@mcjack.com", note: "It’s hard to..."}
  ]
}
								</code></pre>
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h1>Schema Evolution for read-heavy use #3</h1>
						<h3>Users want to comment on other people's notes</h3>
						<pre class="fragment"><code class="language-javascript small-size">
bookNotes = {
  "_id": int, 
  "book": int, // this is the book id
  "note_count": int,
  "last_changed": datetime,
  "notes": [{
    "user": string,
    "note": string,
    "comments": [{
      "user": string,
      "text": string,
      "replies": [{
        "user": string,
        "text": string,
        "replies": [{...}]
      }]
    }]
  }]
}
						</code></pre>
					</section>
					
					<section>
						<h3>What benefits does this provide?</h3>
						<ul>
							<li class="fragment">
								Single document for all comments on a note.
							</li>
							<li class="fragment">
								Single location on disk for the whole tree.
							</li>
							<li class="fragment">
								Legible tree structure.
							</li>
						</ul>
						<br/>
						<h3>What are the drawbacks of storing a tree in this way?</h3>
						<ul>
							<li class="fragment">
								Difficult to search.
							</li>
							<li class="fragment">
								Difficult to get back partial results.
							</li>
							<li class="fragment">
								Document can get large very quickly.
							</li>
						</ul>
					</section>
							
					<section>
						<h1>Alternative solution: <br/>Store arrays of ancestors</h1>
						<pre><code class="language-javascript small-size">
> t = db.mytree;

> t.find()
{ _id: "a" }
{ _id: "b", ancestors: [ "a" ], parent: "a" }
{ _id: "c", ancestors: [ "a", "b" ], parent: "b" }
{ _id: "d", ancestors: [ "a", "b" ], parent: "b" }
{ _id: "e", ancestors: [ "a" ], parent: "a" }
{ _id: "f", ancestors: [ "a", "e" ], parent: "e" }
{ _id: "g", ancestors: [ "a", "b", "d" ], parent: "d" }

						</code></pre>
						<br />
						<h3 class="fragment">How would you do it?</h3>
					</section>
					
				</section>
				<section>
					<h1>General notes for read-heavy schemas</h1>
					<h3>Think about indexes and sharding</h3>
					<ul>
						<li class="fragment">
							Multi-key indexes.
						</li>
						<li class="fragment">
							Secondary indexes.
						</li>
						<li class="fragment">
							Shard key choice.
						</li>
					</ul>

				</section>
					
 <aside class="notes">
All docs must have the shard key
Shard key values are immutable once the doc is inserted
How will your query using the shard key
Make sure that sorting by shard key can be efficient 
 </aside>				
 
				<section>
					<section>
						<h1>Schema Evolution for write-heavy use</h1>
						<h3>Add notes to a book</h3>
						<pre><code class="language-javascript small-size">
> note = { user: "craig.wilson@10gen.com", "I did NOT like this book." }

> db.books.update({ _id: 1 }, { $push: { notes: note }})
						</code></pre>
					</section>
					<section>
						<h3>Principle: Take Advantage of Atomic Operations</h3>
						<ul class="fragment">
							<li>$set - set a value</li>
							<li>$unset - unsets a value</li>
							<li>$inc - increment an integer</li>
							<li>$push - append a value to an array</li>
							<li>$pushAll - append several values to an array</li>
							<li>$pull - remove a value from an array</li>
							<li>$pullAll - remove several values from an array</li>
							<li>$bit - bitwise operations</li>
							<li>$addToSet - adds a value to a set if it doesn't already exist</li>
							<li>$rename - renames a field</li>
						</ul>
					</section>
					<section>
						<h3>Anti-pattern: Continually Growing Documents</h3>
						<ul>
							<li class="fragment">Because of the limit on document size, documents-- including the top-level content and all subdocuments-- cannot grow beyond 16 megabytes.</li>
							<li class="fragment">Storage fragmentation and degraded update performance while MongoDB migrates documents internally.</li>
							<li class="fragment">Documents can grow to become unnecessarily large.</li>
						</ul>
						<br/>
						<h3 class="fragment">What is an alternative to storing the notes in an array?</h3>
					</section>
					<section>
						<h3>Possible Solution</h3>
						<ul>
							<li>
								Move notes to another document, with one document per book id.
								<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  ... // remove the notes field
}

bookNotes = {
  "_id": int, // this will be the same as the book id...
  "notes": [{
    "user": string,
    "note": string
  }]
}
								</code></pre>
							</li>
							<li class="fragment">Keeps the books document size consistent.</li>
							<li class="fragment">Queries for books don't return all the notes.</li>
							<li class="fragment">Still suffers from a continually growing bookNotes document.</li>
						</ul>
	
</section>
					<section>
						<h3>Possible Solution</h3>
						<ul>
							<li>
								Move notes to another document with one document per note.
								<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  ... // remove the notes field
}

bookNotes = {
  "_id": int, 
  "book": int, // this will be the same as the book id...
  "date": timestamp,
  "user": string,
  "note": string
}
								</code></pre>
							</li>
							<li class="fragment">Keeps the book document size consistent.</li>
							<li class="fragment">Queries for books don't return all the notes.</li>
							<li class="fragment">Notes not necessarily near each other on disk. Possibly slow reads.</li>
						</ul>
					</section>
					
					<section>
						<h3>Pattern: Bucketing</h3>
						<ul>
							<li class="fragment">
								bookNotes contains a maximum number of documents
								<pre><code class="language-javascript small-size">
bookNotes = {
  "_id": int, 
  "book": int, // this is the book id
  "note_count": int,
  "last_changed": datetime,
  "notes": [{
    "user": string,
    "note": string
  }]
}
								</code></pre>
							</li>
							<li class="fragment">
								Still use atomic operations to update an existing document or start a new one
								<pre><code class="language-javascript small-size">
> note = { user: "craig.wilson@10gen.com", "I did NOT like this book." }

> db.bookNotes.update({
	{ book: 1, note_count { $lt: 10 } },
	{ 
		$inc: { note_count: 1 }, 
		$push { notes: note }, 
		$set: { last_changed: new Date() } 
	},
	true // upsert
})
							</code></pre>
							</li>
						</ul>
					</section>
				</section>

				
				
				<section>
					<h1>Schema design in mongoDB</h1>
					<br/>
					<h2 class="fragment">Basic design principles apply.</h2><br/>
					<h2 class="fragment">Focus on how your application uses and changes the data when designing a schema.</h2><br/>
					<h2 class="fragment">Take advantage of the flexibility and features of mongoDB.</h2><br/>
					<h2 class="fragment">Anticipate document and collection growth over time.</h2>
				</section>
				
			</div>

			<!-- The navigational controls UI -->
			<aside class="controls">
				<a class="left" href="#">&#x25C4;</a>
				<a class="right" href="#">&#x25BA;</a>
				<a class="up" href="#">&#x25B2;</a>
				<a class="down" href="#">&#x25BC;</a>
			</aside>

			<!-- 10gen footer -->
			<div class="footer"></div>

			<!-- Presentation progress bar -->
			<div class="progress"><span></span></div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,

				transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/linear(2d)

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'socket.io/socket.io.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
					{ src: 'plugin/speakernotes/client.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
				]
			});

			/* Set slide classes as well so we can print backgrounds and
			   See them in the overview modes
			*/
			var dataStates = document.querySelectorAll( '[data-state]' );
			for (var i = 0; i < dataStates.length; i++ ) {
				var element = dataStates[i];
				var slideState = element.getAttribute( 'data-state' );
				if (!slideState) { continue; }
				var classList = slideState.split(' ');
				for( var x = 0; x < classList.length; x++ ) {
					console.log(classList[x], element.classList, element);
					element.classList.add( classList[x] );
				}
			}

		</script>

	</body>
</html>