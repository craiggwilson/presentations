<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Schema Design By Example</title>

		<meta name="description" content="Schema Design by Example">
		<meta name="author" content="10gen">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/main.css">
		<link rel="stylesheet" href="css/theme/mongodb.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script>
			// If the query includes 'print-pdf' we'll use the PDF print sheet
			var print = ( window.location.search.match( /print-pdf/gi ) ? true: false );
			document.write( '<link rel="stylesheet" href="css/print/' + ( print ? 'pdf': 'paper' ) + '.css" type="text/css" media="print">' );
			if (print) { document.querySelector( 'html' ).classList.add('print');}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

		<style>
			div.reveal section aside.notes {
				background-color: #fff;
				border: 1px solid black;
				color: #000;
				display: block;
				font-size: 20px;
			}
		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Used to fade in a background when a specific slide state is reached -->
			<div class="state-background"></div>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<section>
						<h1>Modern Application Development with MongoDB is Easier</h1>

						<ul>
							<li>Most concepts aren't relational.</li>
							<li>Building understandable schemas that scale is possible.</li>
							<li>Object-Oriented Persistence Mechanisms Map Naturally to MongoDB.</li>
						</ul>
					</section>
				</section>

				<section data-state="title-slide">
					<h1 class="logo">MongoDB</h1>
					<h2>Schema Design By Example</h2>

					Craig Wilson - <craig.wilson@10gen.com>

					twitter: <a href="http://twitter.com/craiggwilson">@craiggwilson</a>
				</section>

				<section>
					<h1>Differences with Traditional Schema Design</h1>

					<table>
						<tr>
							<th>Traditional</th>
							<th>MongoDB</th>
						</tr>
						<tr>
							<td>Your application doesn't matter.</td>
							<td>It's always about your application.</td>
						</tr>
						<tr>
							<td>Only About the Data</td>
							<td>Not Only About the Data, but also how it's used.</td>
						</tr>
						<tr>
							<td>Only relevant during design.</td>
							<td>Relevant during the lifetime of your application.</td>
						</tr>
					</table>
				</section>

				<section>
					<h1>Schema Design is Evolutionary</h1>

					<ul>
						<li>Design and Development.</li>
						<li>Deployment and Monitoring.</li>
						<li>Iterative Modification.</li>
					</ul>

					<aside class="notes">
						<p>Every application goes through a lifetime.</p>
						<p>Each stage brings changes to the schema.</p>
						<p>Each stage of the lifetime offers the opportunity to make choices.</p>
					</aside>
				</section>

				<section>
					<h1>3 Components to Schema Design</h1>

					<ol>
						<li>The Data Your Application Needs.</li>
						<li>How Your Application Will Read the Data.</li>
						<li>How Your Application Will Write the Data.</li>
					</ol>

					<aside class="notes">
						<p>Unlike a relational database where there is a very prescriptive way to build a schema, MongoDB offers lots of flexibility.</p>
						<p>These components come up through each stage in the lifetime of an application.</p>
					</aside>
				</section>

				<section>
					<section>
						<h1>What is a Document Database?</h1>

						<ul>
							<li>Storage in json.</li>
							<li>Application-defined schema</li>
							<li>...</li>
						</ul>
						<aside class="notes">
							<p>Discuss how this type of database provides opportunity for choice.</p>
						</aside>
					</section>
					<section>
						<h1>Schema - Author</h1>
						<pre><code class="language-javascript small-size">
author = {
  "_id": int,
  "first_name": string,
  "last_name": string
}
						</code></pre>
					</section>
					<section>
						<h1>Schema - User</h1>
						<pre><code class="language-javascript small-size">
user = {
  "_id": int,
  "username": string,
  "password": string
}
						</code></pre>
					</section>
					<section>
						<h1>Schema - Book</h1>
						<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  "title": string,
  "author": int,
  "isbn": string,
  "slug": string,
  "publisher": {
    "name": string,
    "date": timestamp,
    "city": string
  },
  "available": boolean,
  "pages": int,
  "summary": string,
  "subjects": [string, string]
  "notes": [{
  	"user": int,
  	"note": string
  }],
  "language": string
}
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Example: Library Application</h1>

						<p>An application for saving a collection of books.<p>
					</section>
					<section>
						<img src="img/books_index.png" style="max-height:150%;"/>
					</section>
					<section>
						<img src="img/authors_index.png" style="max-height:150%;"/>
					</section>
				</section>

				<section>
					<section>
						<h1>Some Sample Documents</h1>

						<pre><code class="language-javascript small-size">
> db.authors.findOne()
{
  _id: 1,
  first_name: "F. Scott",
  last_name: "Fitgerald"
}

> db.users.findOne()
{
  _id: 1,
  username: "craig.wilson@10gen.com",
  password: "slsjfk4odk84k209dlkdj90009283d"
}
						</code></pre>
					</section>
					<section>
						<pre><code class="language-javascript small-size">
> db.books.findOne()
{
  _id: 1,
  title: "The Great Gatsby",
  slug: "9781857150193-the-great-gatsby",
  author: 1,
  available: true,
  isbn: "9781857150193",
  pages: 176,
  publisher: {
    publisher_name: "Everyman’s Library",
    date: ISODate("1991-09-19T00:00:00Z"),
    publisher_city: "London"
  },
  summary: "Set in the post-Great War...",
  subjects: ["Love stories", "1920s", "Jazz Age"],
  notes: [ 
    { user: 1, note: "One of the best..."},
    { user: 2, note: "It’s hard to..."}
  ],
  language: "English"
}
						</code></pre>
					</section>
				</section>
				
				<section class="center-image">
					<h1>Design and Development.</h1>
				</section>
				<section>
					<section>
						<h1>The Data Our Library Needs</h1>
						<ul>
							<li>
								Embedded Documents
								<pre><code class="language-javascript small-size">
book.publisher: 
{
  publisher_name: "Everyman’s Library",
  date: ISODate("1991-09-19T00:00:00Z"),
  city: "London"
}
								</code></pre>
							</li>
							
							<aside class="notes">
								<p>In general, use embedded documents when possible.</p>
								<p>Usually one embeds documents that seldom change and data that's not interesting enough to warrant a document of its own.</p>
							</aside> 
			
							<li>
								Embedded Arrays
								<pre><code class="language-javascript small-size">
book.subjects: ["Love stories", "1920s", "Jazz Age"],
								</code></pre>
							</li>
							
							<aside class="notes">
								<p>Multi-key indexes - will index each element of the array.</p>
								<p>Query: db.books.find( { subject: { $all: [ 'Love stories', 'Jazz Age' ] } } )</p>
								<p>$addToSet and $pull to add and remove keys</p>
								<p>Whether to embed positionally using an array or embedded doc is a matter of taste and depends on whether you want to use a multi-key index.</p>
							</aside>

							<li>
								Embedded Arrays of Documents
								<pre><code class="language-javascript small-size">
book.notes: [
  { user: 1, note: "One of the best..."},
  { user: 2, note: "It’s hard to..."}
],
								</code></pre>
							</li>
							
							<aside class="notes">
								<p>You can even index on keys inside embedded documents.</p>
							</aside>
						</ul>
					</section>
					</section>
				<section>
					<section>
						<h1>How Our Library Reads Data.</h1>
						<h3>Query for all the books by a specific author</h3>
						<pre><code class="language-javascript small-size">
> author = db.authors.findOne({first_name: "F. Scott", last_name: "Fitzgerald"});

> db.books.find({author: author._id})
{
  ...	
}
{
  ...
}
						</code></pre>	
					</section>
					
					<section>
						<h3>Query for books by title</h3>
						<pre><code class="language-javascript small-size">
> db.books.find({title: "The Great Gatsby"})
{
  ...	
}
						</code></pre>
						<aside class="notes">
							<p>We have to first find the author before we find the books.</p>
						</aside>
					</section>
					<section>
						<h3>Query for books in which I have made notes</h3>
						<pre><code class="language-javascript small-size">
> db.books.find({notes.user: 1})
{
  ...	
}
{
  ...
}
						</code></pre>
						<aside class="notes">
							<p>We have to know the user's id before we can do this query.</p>
							<p>If we wanted to find notes by a different user, we'd first have to find that user.</p>
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>How Our Library Writes Data.</h1>
						<h3>Add notes to a book</h3>
						<pre><code class="language-javascript small-size">
> note = { user: 1, note: "I did NOT like this book." }

> db.books.update({ _id: 1 }, { $push: { notes: note }})
						</code></pre>
					</section>
					<section>
						<h3>Take Advantage of Atomic Operations</h3>
						<ul>
							<li>$set - set a value</li>
							<li>$unset - unsets a value</li>
							<li>$inc - increment an integer</li>
							<li>$push - append a value to an array</li>
							<li>$pushAll - append several values to an array</li>
							<li>$pull - remove a value from an array</li>
							<li>$pullAll - remove several values from an array</li>
							<li>$bit - bitwise operations</li>
							<li>$addToSet - adds a value to a set if it doesn't already exist</li>
							<li>$rename - renames a field</li>
						</ul>
					</section>
				</section>
				<section>
					<h1>Deployment and Monitoring</h1>

					<aside class="notes">
						<p>Describe some issues we encountered and how we'll fix them.</p>
						<p>Also note thate we are skipping the "The Date Our App Needs" because that hasn't changed in this lifetime phase.</p>
					</aside>
				</section>
				<section>
					<section>
						<h1>How Our Library Reads Data</h1>
						<h3>Query for books by an author's first name</h3>
						<pre><code class="language-javascript small-size">
> authors = db.authors.find( { first_name: /^f.*/i }, {_id: 1})

> authorIds = authors.map(function(x) { return x._id; })

> db.books.find({author: { $in: authorIds } })
{
  ...	
}
{
  ...
}
						</code></pre>
						<aside class="notes">
							<p>Turns out many of users didn't know the full author's name and wanted to search by partial names.</p>
						</aside>
					</section>
					<section>
						<h3>Documents Should Reflect Query Patterns</h3>
						<ul>
							<li>
								Partially Embedded Documents
								<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  "title": string,
  "author": {
    "author": int,
    "name": string
  },
  ...
}
								</code></pre>
							</li>
						<li>
							Query for books by an author's first name using an embedded document with a denormalized name.
							<pre><code class="language-javascript small-size">
> db.books.find({author.name: /^f.*/i })
{
  ...	
}
{
  ...
}
							</code></pre>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h1>How Our Library Reads Data</h1>
						<h3>Query for a book's notes</h3>
						<pre><code class="language-javascript small-size">
> db.books.find({title: "The Great Gatsby"}, {_notes: 1})
{
  _id: 1,
  notes: [
    { user: 1, note: "One of the best..."},
    { user: 2, note: "It’s hard to..."}
  ]
}
						</code></pre>
						<aside class="notes">
							<p>Turns out we were killing our database because we had to go back to it for every note to get the author.</p>
						</aside>
					</section>
					<section>
						<h3>Take Advantage of Immutable Data</h3>
						<ul>
							<li>
								Username is the natural key and is immutable
								<pre><code class="language-javascript small-size">
user = {
  "_id": string,
  "password": string
}

book = {
  // ...
  "notes": [{
    "user": string,
    "note": string
  }],
  // ...
}
								</code></pre>
							</li>
							<li>
								Query for a book's notes
								<pre><code class="language-javascript small-size">
> db.books.find({title: "The Great Gatsby"}, {notes: 1})
{
  _id: 1,
  notes: [
    { user: "craig.wilson@10gen.com", note: "One of the best..."},
    { user: "jmcjack@mcjack.com", note: "It’s hard to..."}
  ]
}
								</code></pre>
							</li>
						</ul>
					</section>
				</section>
 
				<section>
					<section>
						<h1>How Our Library Writes Data</h1>
						<h3>Add notes to a book</h3>
						<pre><code class="language-javascript small-size">
> note = { user: "craig.wilson@10gen.com", "I did NOT like this book." }

> db.books.update({ _id: 1 }, { $push: { notes: note }})
						</code></pre>
						<aside class="notes">
							<p>Turns out that our writes were causing problems by continually growing the document's size.  Data locality is the cornerstone for performance in MongoDB.</p>
						</aside>
					</section>
					<section>
						<h3>Anti-pattern: Continually Growing Documents</h3>
						<ul>
							<li>Document Size Limit</li>
							<li>Storage Fragmentation</li>
						</ul>

						<aside class="notes">
							<p>Describe the detrimental effects this has upon a database.</p>
						</aside>
					</section>
					<section>
						<h3>Linking: One-to-One relationship</h3>
						<ul>
							<li>
								Move notes to another document, with one document per book id.
								<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  ... // remove the notes field
}

bookNotes = {
  "_id": int, // this will be the same as the book id...
  "notes": [{
    "user": string,
    "note": string
  }]
}
								</code></pre>
							</li>
							<li>Keeps the books document size consistent.</li>
							<li>Queries for books don't return all the notes.</li>
							<li>Still suffers from a continually growing bookNotes document.</li>
						</ul>
	
</section>
					<section>
						<h3>Linking: One-to-Many relationship</h3>
						<ul>
							<li>
								Move notes to another document with one document per note.
								<pre><code class="language-javascript small-size">
book = {
  "_id": int,
  ... // remove the notes field
}

bookNotes = {
  "_id": int, 
  "book": int, // this will be the same as the book id...
  "date": timestamp,
  "user": string,
  "note": string
}
								</code></pre>
							</li>
							<li>Keeps the book document size consistent.</li>
							<li>Queries for books don't return all the notes.</li>
							<li>Notes not necessarily near each other on disk. Possibly slow reads.</li>
						</ul>
					</section>
					
					<section>
						<h3>Bucketing</h3>
						<ul>
							<li>
								bookNotes contains a maximum number of documents
								<pre><code class="language-javascript small-size">
bookNotes = {
  "_id": int, 
  "book": int, // this is the book id
  "note_count": int,
  "last_changed": datetime,
  "notes": [{
    "user": string,
    "note": string
  }]
}
								</code></pre>
							</li>
							<li>
								Still use atomic operations to update an existing document or start a new one
								<pre><code class="language-javascript small-size">
> note = { user: "craig.wilson@10gen.com", "I did NOT like this book." }

> db.bookNotes.update({
	{ book: 1, note_count { $lt: 10 } },
	{ 
		$inc: { note_count: 1 }, 
		$push { notes: note }, 
		$set: { last_changed: new Date() } 
	},
	true // upsert
})
							</code></pre>
							</li>
						</ul>
					</section>
				</section>

				<section>
					<h1>Interative Modification</h1>

					<aside class="notes">
						<p>Customers have asked for more features.</p>
						<p>Business needs to change direction.</p>
					</aside>
				</section>

				<section>
					<section>
						<h1>The Data Our Library Needs</h1>
						<h3>Users want to comment on other people's notes</h3>
						<pre><code class="language-javascript small-size">
bookNotes = {
  "_id": int, 
  "book": int, // this is the book id
  "note_count": int,
  "last_changed": datetime,
  "notes": [{
    "user": string,
    "note": string,
    "comments": [{
      "user": string,
      "text": string,
      "replies": [{
        "user": string,
        "text": string,
        "replies": [{...}]
      }]
    }]
  }]
}
						</code></pre>
					</section>
					
					<section>
						<h3>What benefits does this provide?</h3>
						<ul>
							<li>
								Single document for all comments on a note.
							</li>
							<li>
								Single location on disk for the whole tree.
							</li>
							<li>
								Legible tree structure.
							</li>
						</ul>
						<br/>
						<h3>What are the drawbacks of storing a tree in this way?</h3>
						<ul>
							<li>
								Difficult to search.
							</li>
							<li>
								Difficult to get back partial results.
							</li>
							<li>
								Document can get large very quickly.
							</li>
						</ul>
					</section>
							
					<section>
						<h1>Alternative solution: <br/>Store arrays of ancestors</h1>
						<pre><code class="language-javascript small-size">
> t = db.mytree;

> t.find()
{ _id: "a" }
{ _id: "b", ancestors: [ "a" ], parent: "a" }
{ _id: "c", ancestors: [ "a", "b" ], parent: "b" }
{ _id: "d", ancestors: [ "a", "b" ], parent: "b" }
{ _id: "e", ancestors: [ "a" ], parent: "a" }
{ _id: "f", ancestors: [ "a", "e" ], parent: "e" }
{ _id: "g", ancestors: [ "a", "b", "d" ], parent: "d" }

						</code></pre>
						<br />
						<h3>How would you do it?</h3>
					</section>
					
				</section>
				<section>
					<h1>General notes for read-heavy schemas</h1>
					<h3>Think about indexes and sharding</h3>
					<ul>
						<li>
							Multi-key indexes.
						</li>
						<li>
							Secondary indexes.
						</li>
						<li>
							Shard key choice.
						</li>
					</ul>

					<aside class="notes">
						<p>All docs must have the shard key.</p>
						<p>Shard key values are immutable once the doc is inserted.</p>
						<p>How will you query using the shard key?.</p>
						<p>Sorting by shard key must be efficient.</p>
					</aside>
				</section>
				
				<section>
					<h1>Schema design in mongoDB</h1>
					<br/>
					<h2>It's about your application.</h2>
					<h2>It's about your data and how it's used.</h2>
					<h2>It's about the entire lifetime of your application.</h2>
				</section>

				<section>
					<h1>Examples of schemas that are incredibly difficult to build using traditional databases.</h1>

					<ul>
						<li>E-commerce - product catalogs (show pictures)</li>
						<li>...</li>
					</ul>
				</section>
			</div>

			<!-- The navigational controls UI -->
			<aside class="controls">
				<a class="left" href="#">&#x25C4;</a>
				<a class="right" href="#">&#x25BA;</a>
				<a class="up" href="#">&#x25B2;</a>
				<a class="down" href="#">&#x25BC;</a>
			</aside>

			<!-- 10gen footer -->
			<div class="footer"></div>

			<!-- Presentation progress bar -->
			<div class="progress"><span></span></div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,

				transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/linear(2d)

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'socket.io/socket.io.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
					{ src: 'plugin/speakernotes/client.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
				]
			});

			/* Set slide classes as well so we can print backgrounds and
			   See them in the overview modes
			*/
			var dataStates = document.querySelectorAll( '[data-state]' );
			for (var i = 0; i < dataStates.length; i++ ) {
				var element = dataStates[i];
				var slideState = element.getAttribute( 'data-state' );
				if (!slideState) { continue; }
				var classList = slideState.split(' ');
				for( var x = 0; x < classList.length; x++ ) {
					console.log(classList[x], element.classList, element);
					element.classList.add( classList[x] );
				}
			}

		</script>

	</body>
</html>